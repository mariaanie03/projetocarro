// server.js (Vers√£o Final Completa e Corrigida)

// =======================================================
// ----- IMPORTA√á√ïES -----
// =======================================================
import express from 'express';
import dotenv from 'dotenv';
import mongoose from 'mongoose';
import cors from 'cors';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import axios from 'axios';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import multer from 'multer';
import { body, validationResult } from 'express-validator';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

// Importa√ß√£o dos modelos do Mongoose
import Veiculo from './models/Veiculo.js';
import Manutencao from './models/Manutencao.js';
import User from './models/User.js';
import RemovedVehicleLog from './models/RemovedVehicleLog.js';

// =======================================================
// ----- CONFIGURA√á√ÉO INICIAL -----
// =======================================================
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, '.env') });

const app = express();
const port = process.env.PORT || 3000;

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
    console.error("‚ùå [ERRO FATAL] JWT_SECRET n√£o configurado no .env! O sistema de autentica√ß√£o n√£o funcionar√°.");
    process.exit(1);
}

// Limitadores de requisi√ß√£o
const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: 'Muitas requisi√ß√µes para a API, tente novamente mais tarde.'
});
const createVehicleLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 10,
    message: 'Voc√™ atingiu o limite de cria√ß√£o de ve√≠culos. Por favor, tente novamente mais tarde.'
});
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 50,
    message: 'Muitas tentativas de autentica√ß√£o ou registro, por favor, tente novamente mais tarde.'
});

// =======================================================
// ----- CONFIGURA√á√ÉO DO MULTER (UPLOAD DE ARQUIVOS) -----
// =======================================================
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadPath = path.join(__dirname, 'uploads/');
    if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname);
  }
});
const upload = multer({ storage: storage });

// =======================================================
// ----- CONEX√ÉO COM O BANCO DE DADOS -----
// =======================================================
mongoose.connect(process.env.MONGO_URI_CRUD).then(() => {
    console.log("üöÄ [Mongoose] Conectado com sucesso ao MongoDB Atlas!");
}).catch(err => {
    console.error("‚ùå [Mongoose ERRO FATAL] Falha ao conectar:", err.message);
    process.exit(1);
});

// =======================================================
// ----- MIDDLEWARES E DADOS EST√ÅTICOS -----
// =======================================================
app.use(helmet());
app.use(cors());
app.use(express.json({ limit: '10kb' }));
app.use(express.static(__dirname));
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));
app.use('/api/', apiLimiter);

let dados = {};
try {
    const rawData = fs.readFileSync(path.join(__dirname, 'dados.json'));
    dados = JSON.parse(rawData);
} catch (error) {
    console.error('[Servidor ERRO] N√£o foi poss√≠vel carregar dados.json:', error);
}

// =======================================================
// ----- MIDDLEWARE DE AUTENTICA√á√ÉO (JWT) -----
// =======================================================
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (token == null) return res.status(401).json({ message: 'Acesso n√£o autorizado: Nenhum token fornecido.' });
    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) return res.status(403).json({ message: 'Token inv√°lido ou expirado.' });
        req.user = user;
        next();
    });
};

// =======================================================
// ----- ROTAS DA API -----
// =======================================================

// --- ROTAS DE AUTENTICA√á√ÉO ---
app.post('/api/auth/register', authLimiter, [
    body('email', 'Email inv√°lido').isEmail().normalizeEmail(),
    body('password', 'A senha deve ter no m√≠nimo 6 caracteres.').isLength({ min: 6 })
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array().map(err => err.msg) });
    const { email, password } = req.body;
    try {
        let user = await User.findOne({ email });
        if (user) return res.status(409).json({ message: 'Este email j√° est√° registrado.' });
        user = new User({ email, password });
        await user.save();
        const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, { expiresIn: '1h' });
        res.status(201).json({ message: 'Usu√°rio registrado com sucesso!', token, email: user.email });
    } catch (error) {
        res.status(500).json({ message: 'Erro interno do servidor ao registrar o usu√°rio.' });
    }
});

app.post('/api/auth/login', authLimiter, [
    body('email', 'Email inv√°lido').isEmail().normalizeEmail(),
    body('password', 'A senha √© obrigat√≥ria.').not().isEmpty()
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array().map(err => err.msg) });
    const { email, password } = req.body;
    try {
        const user = await User.findOne({ email });
        if (!user || !(await user.comparePassword(password))) return res.status(400).json({ message: 'Credenciais inv√°lidas.' });
        user.lastLogin = new Date();
        user.loginCount = (user.loginCount || 0) + 1;
        await user.save();
        const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, { expiresIn: '1h' });
        res.status(200).json({ message: 'Login realizado com sucesso!', token, email: user.email });
    } catch (error) {
        res.status(500).json({ message: 'Erro interno do servidor ao fazer login.' });
    }
});

app.get('/api/auth/me', authenticateToken, async (req, res) => {
    try {
        const user = await User.findById(req.user.id).select('-password');
        if (!user) return res.status(404).json({ message: 'Usu√°rio n√£o encontrado.' });
        res.status(200).json({ user });
    } catch (error) {
        res.status(500).json({ message: 'Erro interno do servidor.' });
    }
});

// --- ROTAS CRUD PARA VE√çCULOS ---
app.post('/api/veiculos', authenticateToken, createVehicleLimiter, upload.single('imagemVeiculo'), [
    body('placa').matches(/^[A-Z]{3}\d{1}[A-Z]{1}\d{2}$|^[A-Z]{3}\d{4}$/).trim().toUpperCase(),
    body('marca').not().isEmpty().trim().escape(),
    body('modelo').not().isEmpty().trim().escape(),
    body('ano').isInt({ min: 1900, max: new Date().getFullYear() + 2 }).toInt(),
    body('cor').not().isEmpty().trim().escape(),
    body('tipo').isIn(['Carro', 'CarroEsportivo', 'Caminhao'])
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ message: `Dados inv√°lidos: ${errors.array().map(e => e.msg).join(', ')}` });
    try {
        const imageUrl = req.file ? req.file.path.replace(/\\/g, "/") : null;
        const veiculoCriado = await Veiculo.create({ ...req.body, owner: req.user.id, imageUrl: imageUrl });
        res.status(201).json(veiculoCriado);
    } catch (error) {
        if (error.code === 11000) return res.status(409).json({ message: 'Erro: A placa informada j√° existe.' });
        res.status(500).json({ message: 'Erro interno do servidor ao criar o ve√≠culo.' });
    }
});

app.get('/api/veiculos', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id; 
        const todosOsVeiculos = await Veiculo.find({ $or: [{ owner: userId }, { sharedWith: userId }] })
            .populate({ path: 'historicoManutencao', model: 'Manutencao', options: { sort: { 'data': -1 } } })
            .populate('owner', 'email').populate('sharedWith', 'email').sort({ createdAt: -1 });
        res.status(200).json(todosOsVeiculos);
    } catch (error) {
        res.status(500).json({ message: 'Erro ao buscar os ve√≠culos.' });
    }
});

app.put('/api/veiculos/:id', authenticateToken, [
    body('placa').matches(/^[A-Z]{3}\d{1}[A-Z]{1}\d{2}$|^[A-Z]{3}\d{4}$/).trim().toUpperCase(),
    body('marca').not().isEmpty().trim().escape(),
    body('modelo').not().isEmpty().trim().escape(),
    body('ano').isInt({ min: 1900, max: new Date().getFullYear() + 2 }).toInt(),
    body('cor').not().isEmpty().trim().escape(),
    body('tipo').isIn(['Carro', 'CarroEsportivo', 'Caminhao'])
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ message: `Dados inv√°lidos: ${errors.array().map(e => e.msg).join(', ')}` });
    try {
        const veiculo = await Veiculo.findOne({ _id: req.params.id, owner: req.user.id });
        if (!veiculo) return res.status(404).json({ message: "Ve√≠culo n√£o encontrado ou voc√™ n√£o tem permiss√£o para atualiz√°-lo." });
        const veiculoAtualizado = await Veiculo.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
        res.status(200).json(veiculoAtualizado);
    } catch (error) {
        if (error.code === 11000) return res.status(409).json({ message: 'Erro: Essa placa j√° pertence a outro ve√≠culo.' });
        res.status(500).json({ message: 'Erro interno do servidor ao atualizar o ve√≠culo.' });
    }
});

app.delete('/api/veiculos/:id', authenticateToken, async (req, res) => {
    try {
        const veiculoToDelete = await Veiculo.findOne({ _id: req.params.id, owner: req.user.id });
        if (!veiculoToDelete) return res.status(404).json({ message: "Ve√≠culo n√£o encontrado ou voc√™ n√£o tem permiss√£o para delet√°-lo." });
        
        // Opcional: Remover a imagem associada do sistema de arquivos
        if (veiculoToDelete.imageUrl) {
            fs.unlink(path.join(__dirname, veiculoToDelete.imageUrl), (err) => {
                if (err) console.error("Erro ao deletar a imagem do ve√≠culo:", err);
            });
        }
        
        await Manutencao.deleteMany({ veiculo: req.params.id });
        await Veiculo.findByIdAndDelete(req.params.id);
        res.status(200).json({ message: `Ve√≠culo ${veiculoToDelete.placa} deletado com sucesso.` });
    } catch (error) {
        res.status(500).json({ message: 'Erro ao deletar o ve√≠culo.' });
    }
});


// --- CORRE√á√ÉO: ROTAS DE COMPARTILHAMENTO, MANUTEN√á√ÉO, DICAS E PREVIS√ÉO RESTAURADAS ---

// ROTA: COMPARTILHAR UM VE√çCULO
app.post('/api/veiculos/:veiculoId/share', authenticateToken, async (req, res) => {
    try {
        const { veiculoId } = req.params;
        const { email } = req.body;
        const ownerId = req.user.id;

        if (!email) return res.status(400).json({ message: "O email do usu√°rio para compartilhamento √© obrigat√≥rio." });

        const veiculo = await Veiculo.findById(veiculoId);
        if (!veiculo) return res.status(404).json({ message: "Ve√≠culo n√£o encontrado." });

        if (veiculo.owner.toString() !== ownerId) return res.status(403).json({ message: "Acesso proibido. Apenas o propriet√°rio pode compartilhar o ve√≠culo." });

        const userToShareWith = await User.findOne({ email: email.toLowerCase() });
        if (!userToShareWith) return res.status(404).json({ message: `Usu√°rio com o email "${email}" n√£o encontrado.` });
        
        if (userToShareWith.id === ownerId) return res.status(400).json({ message: "Voc√™ n√£o pode compartilhar um ve√≠culo com voc√™ mesmo." });
        
        if (veiculo.sharedWith.includes(userToShareWith.id)) return res.status(409).json({ message: `Este ve√≠culo j√° est√° compartilhado com ${email}.` });

        veiculo.sharedWith.push(userToShareWith._id);
        await veiculo.save();
        res.status(200).json({ message: `Ve√≠culo compartilhado com sucesso com ${email}!` });
    } catch (error) {
        res.status(500).json({ message: 'Erro interno do servidor ao compartilhar o ve√≠culo.' });
    }
});

// ROTA: REVOGAR O COMPARTILHAMENTO DE UM VE√çCULO
app.post('/api/veiculos/:veiculoId/unshare', authenticateToken, async (req, res) => {
    try {
        const { veiculoId } = req.params;
        const { emailToRemove } = req.body;
        const ownerId = req.user.id;

        if (!emailToRemove) return res.status(400).json({ message: "O email do usu√°rio para remover o acesso √© obrigat√≥rio." });

        const veiculo = await Veiculo.findById(veiculoId);
        if (!veiculo) return res.status(404).json({ message: "Ve√≠culo n√£o encontrado." });
        
        const userToRemove = await User.findOne({ email: emailToRemove.toLowerCase() });
        if (!userToRemove) return res.status(404).json({ message: `Usu√°rio com o email "${emailToRemove}" n√£o encontrado.` });

        if (veiculo.owner.toString() !== ownerId) return res.status(403).json({ message: "Acesso proibido. Apenas o propriet√°rio pode revogar o acesso." });

        await Veiculo.updateOne({ _id: veiculoId }, { $pull: { sharedWith: userToRemove._id } });
        res.status(200).json({ message: `Acesso ao ve√≠culo removido com sucesso para ${emailToRemove}.` });
    } catch (error) {
        res.status(500).json({ message: 'Erro interno do servidor ao revogar o compartilhamento.' });
    }
});

// CRIAR UMA NOVA MANUTEN√á√ÉO
app.post('/api/veiculos/:veiculoId/manutencoes', authenticateToken, [
    body('data').isISO8601().toDate(),
    body('descricaoServico').not().isEmpty().trim().escape(),
    body('custo').isFloat({ min: 0 }).toFloat(),
    body('quilometragem').optional({ checkFalsy: true }).isInt({ min: 0 }).toInt()
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ message: `Dados inv√°lidos: ${errors.array().map(e => e.msg).join(', ')}` });
    try {
        const veiculo = await Veiculo.findById(req.params.veiculoId);
        if (!veiculo) return res.status(404).json({ message: "Ve√≠culo n√£o encontrado." });

        if (veiculo.owner.toString() !== req.user.id && !veiculo.sharedWith.map(id => id.toString()).includes(req.user.id)) {
            return res.status(403).json({ message: "Voc√™ n√£o tem permiss√£o para adicionar manuten√ß√µes a este ve√≠culo." });
        }
        const manutencao = await Manutencao.create({ ...req.body, veiculo: req.params.veiculoId });
        veiculo.historicoManutencao.push(manutencao._id);
        await veiculo.save();
        res.status(201).json(manutencao);
    } catch (error) {
        res.status(500).json({ message: "Ocorreu um erro interno no servidor." });
    }
});

// LER TODAS AS MANUTEN√á√ïES DE UM VE√çCULO
app.get('/api/veiculos/:veiculoId/manutencoes', authenticateToken, async (req, res) => {
    try {
        const veiculo = await Veiculo.findById(req.params.veiculoId);
        if (!veiculo) return res.status(404).json({ message: 'Ve√≠culo n√£o encontrado.' });
        if (veiculo.owner.toString() !== req.user.id && !veiculo.sharedWith.map(id => id.toString()).includes(req.user.id)) {
            return res.status(403).json({ message: "Voc√™ n√£o tem permiss√£o para ver as manuten√ß√µes deste ve√≠culo." });
        }
        const manuten√ß√µes = await Manutencao.find({ veiculo: req.params.veiculoId }).sort({ data: -1 });
        res.status(200).json(manuten√ß√µes);
    } catch (error) {
        res.status(500).json({ message: 'Erro interno do servidor.' });
    }
});

// ROTA DE DICAS DE MANUTEN√á√ÉO
app.get('/api/dicas-manutencao/:tipoVeiculo', (req, res) => {
    const { tipoVeiculo } = req.params;
    const mapeamento = { 'carro': 'carro', 'carroesportivo': 'esportivo', 'caminhao': 'caminhao' };
    const chave = mapeamento[tipoVeiculo.toLowerCase()];
    if (chave && dados.dicasManutencao) {
        res.json([...(dados.dicasManutencao.geral || []), ...(dados.dicasManutencao[chave] || [])]);
    } else {
        res.status(404).json({ message: `Nenhuma dica encontrada para o tipo: ${tipoVeiculo}` });
    }
});

// ROTA DE PREVIS√ÉO DO TEMPO
app.get('/api/previsao', async (req, res) => {
    const { cidade } = req.query;
    const apiKey = process.env.OPENWEATHER_API_KEY;
    if (!apiKey) return res.status(500).json({ message: "Chave da API de previs√£o n√£o configurada." });
    if (!cidade) return res.status(400).json({ message: "O nome da cidade √© obrigat√≥rio." });

    const url = `https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(cidade)}&appid=${apiKey}&units=metric&lang=pt_br`;
    try {
        const response = await axios.get(url);
        const previsoesPorDia = {};
        response.data.list.forEach(item => {
            const dia = new Date(item.dt * 1000).toLocaleDateString('pt-BR', { weekday: 'long' });
            if (!previsoesPorDia[dia]) {
                previsoesPorDia[dia] = { diaSemana: dia.charAt(0).toUpperCase() + dia.slice(1), temps: [], descricoes: {}, icones: {} };
            }
            previsoesPorDia[dia].temps.push(item.main.temp);
            previsoesPorDia[dia].descricoes[item.weather[0].description] = (previsoesPorDia[dia].descricoes[item.weather[0].description] || 0) + 1;
            previsoesPorDia[dia].icones[item.weather[0].icon] = (previsoesPorDia[dia].icones[item.weather[0].icon] || 0) + 1;
        });
        const resultado = Object.values(previsoesPorDia).map(diaInfo => ({
            dia: diaInfo.diaSemana,
            temp_min: Math.round(Math.min(...diaInfo.temps)),
            temp_max: Math.round(Math.max(...diaInfo.temps)),
            descricao: Object.keys(diaInfo.descricoes).reduce((a, b) => diaInfo.descricoes[a] > diaInfo.descricoes[b] ? a : b),
            icone: `http://openweathermap.org/img/wn/${Object.keys(diaInfo.icones).reduce((a, b) => diaInfo.icones[a] > diaInfo.icones[b] ? a : b)}.png`
        }));
        res.status(200).json({ cidade: response.data.city.name, previsoes: resultado });
    } catch (error) {
        if (error.response?.status === 404) return res.status(404).json({ message: `Cidade "${cidade}" n√£o encontrada.` });
        res.status(500).json({ message: "N√£o foi poss√≠vel obter a previs√£o do tempo." });
    }
});


// =======================================================
// ----- INICIALIZA√á√ÉO DO SERVIDOR -----
// =======================================================
app.listen(port, () => {
    console.log(`[Servidor] Rodando e escutando em http://localhost:${port}`);
});